> 本文摘自《Effective Objective-C 2.0  编写高质量iOS与OS X代码的52个有效方法》  
> 下文的【要点】均为原书中每点之后的【要点】栏摘抄，注释为本文作者注

# 第1章 熟悉Objective-C
## 4.多用类型常量，少用#define预处理指令
**原因:**  以`#define ANIMATION_DURATION 0.3`为例

1. 这样定义出来的常量没有类型信息
2. 假设此指令声明在某头文件中，那么所有引入了这个头文件的代码，其中的`ANIMATION_DURATION`都会被替换
3. \#define可以重新定义此常量值，编译器给出警告但是允许更改

**更好的写法:**   

	static const NSTimeInterval kAnimationDuration = 0.3;
> **static作用:**该变量仅在定义此变量的编译单元可见。编译器每收到一个编译单元，就会输出一份目标文件(.o)，OC中编译单元通常指每个类的实现文件(.m)，上述声明的变量，作用域仅限于其所在的编译单元生成的目标文件中。如果不加static，编译器会为它创建一个外部符号。此时若是另一个编译单元中也声明了同名变量，那么编译器就会抛出一条错误信息：

>
	duplicate symbol _kAnimationDuration in :
		xxxxxx.o
		xxxxxx.o
> 实际上，如果一个变量既声明为static，又声明为const，编译器便不会创建符号，而是会像#define预处理指令一样，把所有遇到的变量都替换为常值

**常量的命名法:**

1. 若常量局限于某编译单元(也就是实现文件)之内，则在前面加字母k
2. 若常量在类外可见，则通常以类名为前缀

--
> 要点
> 
* 不要用预处理指令定义常量。这样定义出来的常量不含类型信息，编译器只是会在编译前据此执行查找与替换操作。即使有人重新定义了常量值，编译器也不会产生警告信息(==①==)，这将导致应用程序中的常量值不一致。
* 在实现文件中使用static const来定义“只在编译单元内可见的常量”（translation-unit-specific constant）。由于此类常量不在全局符号表中，所以无需为其名称加前缀(==②==)。
* 在头文件中使用extern来声明全局常量，并在相关实现文件中定义其值。这种常量要出现在全局符号表中，所以其名称应加以区隔，通常用与之相关的类名做前置。  

> ==①==:本文写作时Xcode 10会给出警告信息`'xxxxx' macro redefined`  
> ==②==:局限于某编译单元的常量在前面加字母k

## 5.用枚举表示状态、选项、状态码

> 凡是需要以按位或操作来组合的枚举都应使用`NS_OPTIONS`定义。若是枚举不需要互相组合，则应使用`NS_ENUM`来定义。  

**原因:**根据是否要将代码按C++模式编译，`NS_OPTIONS`宏的定义方式也有所不同。如果不按C++编译，那么其展开方式就和`NS_ENUM`相同。若按C++编译，则展开后代码略有不同。原因在于，用按位或运算来操作两个枚举值时，C++编译模式的处理办法和非C++模式不一样。在用或运算操作两个枚举值时，C++认为运算结果的数据类型应该是枚举的底层数据类型。而且C++不允许将这个底层类型“隐式转换”为枚举类型本身，这样在使用的时候就会因为数据类型不匹配而报错。如果想正确编译，就要将结果显示转换，这无疑会使代码变得复杂。因此有以上结论。

> 与一般习惯不同，若是用枚举来定义状态机(switch语句)，则最好不要有default分支。这样的话，如果之后又加了一种状态，那么编译器就会发出警告信息，提示新加入的状态并未在switch分支中处理。    

--
> 要点  
>
* 应该用枚举来表示状态机的状态、传递给方法的选项以及状态码等值，给这些值起个易懂的名字。   
* 如果把传递给某个方法的选项表示为枚举类型，而多个选项又可同时使用，那么就将各选项值定义为2的幂，以便通过按位或操作将其组合起来。
* 用`NS_ENUM`与`NS_OPTIONS`宏来定义枚举类型，并指明其底层数据类型。这样做可以确保是用开发者所选的底层数据类型实现出来的，而不会采用编译器所选的类型。
* 在处理枚举类型的switch语句中不要实现default分支。这样的话，加入新枚举之后，编译器就会提示开发者：switch语句并未处理所有枚举。

#第2章 对象、消息、运行期 
## 6.理解“属性”这一概念
### 属性特质
1. 原子性。默认情况下，由编译器所合成的方法会通过锁定机制确保其原子性。如果属性具备nonatomic特质，则不使用同步锁。  
   
	> 具备atomic特质的获取方法会通过锁定机制来确保操作的原子性。当两个线程读写同一属性，那么不论何时，总能看到有效的属性值。若是不加锁（使用nonatomic语义），那么当其中一个线程正在改写某属性值时，另外一个线程也许会突然闯入，把尚未修改好的属性值读取出来。   
	但是在iOS开发中，所有属性均声明为nonatomic。因为在iOS中使用同步锁的开销较大，带来性能问题。一般情况下并不要求属性必须是原子的，因为这并不能保证“线程安全”。若要实现线程安全的操作，还需采用更为深层的锁定机制才行。例如，一个线程在连续多次读取某属性值的过程中有别的线程同时改写该值，那么即便声明为atomic，也还是会读到不同的属性值。但是在开发Mac OS X程序时，使用atomic属性通常都不会有性能瓶颈。
2. 读写权限   
	* 具备readwrite特质的属性拥有getter与setter。若该属性由@synthesize实现，则编译器会自动生成这两个方法。
	* 具备readonly特质的属性仅拥有getter方法，只有当该属性由@synthesize实现时，编译器才会为其合成获取方法。可以把某个属性对外公开为只读属性，然后在“class-continuation”中将其重新定义为读写属性（27条）。
3. 内存管理语义  
	下面这一组特质仅会影响setter。
	* assign: setter方法只会针对“纯量类型”（scalar type，例如CGFloat或NSInteger等）的简单赋值操作。
	* strong: 此特质表明该属性定义了一种“拥有关系”。为这种属性设置新值时，设置方法会先保留新值，并释放旧值，然后再将新值设置上去。
	* weak: 此特质表明该属性定义了一种“非拥有关系”。为这种属性设置新值时，设置方法既不保留新值，也不释放旧值。此特质同assign类似，然而在属性所指的对象遭到摧毁时，属性值也会清空。
	* unsafe_unretained: 此特质的语义和assign相同，但是它适用于“对象类型”，该特质表达一种“非拥有关系”（不保留，unretained），当目标对象遭到摧毁时，属性值不会自动清空（不安全，unsafe），这一点与weak有区别。
	* copy: 此特质所表达的所属关系与strong类似，然而设置方法不保留新值，而是将其copy。一般用于NSArray、NSDictionary、NSString、block等。  
4. 方法名
	* getter = \<name\>: 指定获取方法的方法名。
	* setter = \<name\>: 指定设置方法的方法名，不常见。  

--
> 要点  
>
* 可以用@property语法来定义对象中所封装的数据。
* 通过“特质”来指定存储数据所需的正确语义。
* 在设置属性所对应的实例变量时，一定要遵从该属性所声明的语义。
* 开发iOS程序时应该使用nonatomic，因为atomic会严重影响性能。

## 7.在对象内部尽量直接访问实例变量
> 除了几种特殊情况外，读取实例变量时采用直接访问的形式，而在设置实例变量的时候通过属性来做。
现有以下两种实现方法；

1. 使用点语法，通过存取方法来访问相关实例变量
	
	``` objc  
	- (NSString *)fullName {
	    return [NSString stringWithFormat:@"%@ %@", self.firstName, self.lastName];
	}
	
	- (void)setFullName:(NSString *)fullName {
	    NSArray *components = [fullName componentsSeparatedByString:@" "];
	    self.firstName = [components objectAtIndex:0];
	    self.lastName = [components objectAtIndex:1];
	}
	
	```

2. 不经由存取方法，直接访问实例变量

	``` objc
	- (NSString *)fullName {
	    return [NSString stringWithFormat:@"%@ %@", _firstName, _lastName];
	}
	
	- (void)setFullName:(NSString *)fullName {
	    NSArray *components = [fullName componentsSeparatedByString:@" "];
	    _firstName = [components objectAtIndex:0];
	    _lastName = [components objectAtIndex:1];
	}
	```

两种写法的区别：  
 
* 由于不经过Objective-C的“方法派发”（method dispatch，参见11条）步骤，所以直接访问实例变量的速度当然比较快。在这种情况下，编译器所生成的代码会直接访问保存对象实例变量的那块内存。
* 直接访问实例变量时，不会调用其“设置方法”，这就绕过了为相关属性所定义的“内存管理语义”。比方说，如果在ARC下直接访问一个声明为copy的属性，那么并不会拷贝该属性，知会保留新值并释放旧值。
* 如果直接访问实例变量，那么不会触发“键值观测”（Key-Value Observing， KVO）通知。这样做是否会产生问题，还取决于具体的对象行为。
* 通过属性来访问有助于排查与之相关的错误，因为可给“获取方法”和/或“设置方法”中新增断点，监控该属性的调用者及其访问时机。

合理的折中方案：在写入实例变量时，通过其“设置方法”来做，而在读取实例变量时，则直接访问。此办法既能提高读取操作的速度，又能控制对属性的写入操作。之所以要通过“设置方法”来写入实例变量，其首要原因在于，这样做能够确保相关属性的”内存管理语义“得以贯彻。

--
> 要点
> 
* 在对象内部读取数据时，应该直接通过实例变量来读，而写入数据时，则应通过属性来写。
* 在初始化方法及dealloc方法中，总是应该直接通过实例变量来读写数据。
* 有时会使用惰性初始化技术配置某份数据，这种情况下，需要通过属性来读取数据。

## 8.理解“对象等同性”这一概念

